<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>2.6. The Level Set method: Part II &#8212; Numerical tours in scientific computing</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=8203d6f3" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=25db1f2b" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="../_static/gen.css?v=1d84c916" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>window.MathJax = {"tex": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "macros": {"calA": "{{\\mathcal A}}", "calC": "{{\\mathcal C}}", "calI": "{{\\mathcal I}}", "calF": "{{\\mathcal F}}", "calL": "{{\\mathcal L}}", "bz": "{\\mathbf{0}}", "d": "{\\text{d}}", "dv": "{\\text{div}}", "e": "{\\varepsilon}", "be": "{\\textbf{e}}", "n": "{\\textbf{n}}", "t": "{\\textbf{t}}", "f": "{\\textbf{f}}", "g": "{\\textbf{g}}", "u": "{\\textbf{u}}", "m": "{\\textbf{m}}", "v": "{\\textbf{v}}", "p": "{\\textbf{p}}", "bj": "{\\textbf{j}}", "bC": "{\\textbf{C}}", "bF": "{\\textbf{F}}", "bU": "{\\textbf{U}}", "bV": "{\\textbf{V}}", "x": "{\\textbf{x}}", "y": "{\\textbf{y}}", "bX": "{\\textbf{X}}", "P": "{\\mathbb{P}}", "R": "{\\mathbb{R}}", "N": "{\\mathbb{N}}", "I": "{\\text{I}}", "Id": "{\\text{Id}}", "o": "{\\text{o}}", "calT": "{{\\mathcal T}}", "Hdiv": "{H_{\\text{div}}}", "tr": "{\\text{tr}}", "bold": ["{\\bf #1}", 1]}, "loader": {"load": ["[tex]/boldsymbol"]}, "packages": {"[+]": ["boldsymbol"]}}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="2.7. Turning to 3d Finite Element problems" href="3dext.html" />
    <link rel="prev" title="2.5. The Level Set method: Part I" href="LSM.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="the-level-set-method-part-ii">
<span id="sec-lsm2"></span><h1><span class="section-number">2.6. </span>The Level Set method: Part II<a class="headerlink" href="#the-level-set-method-part-ii" title="Link to this heading">¶</a></h1>
<p>This second part of our discussion about the Level Set Method deals with slightly more intricate issues, that are notably related to its ability to capture the time evolution of a domain <span class="math notranslate nohighlight">\(\Omega(t)\)</span>.</p>
<section id="initialization-of-a-level-set-representation-by-the-signed-distance-function">
<span id="sec-distls"></span><h2><span class="section-number">2.6.1. </span>Initialization of a Level Set representation by the signed distance function<a class="headerlink" href="#initialization-of-a-level-set-representation-by-the-signed-distance-function" title="Link to this heading">¶</a></h2>
<p>The signed distance function <span class="math notranslate nohighlight">\(d_\Omega\)</span> is one among the many Level Set functions representing a given domain <span class="math notranslate nohighlight">\(\Omega \subset \R^d\)</span>, see <a class="reference internal" href="#fig-2lsfunc"><span class="std std-numref">Fig. 2.14</span></a>.
This section presents a few basic facts about this function, explaining its ubiquitous role in the Level Set framework, and its numerical calculation.</p>
<section id="definition">
<h3><span class="section-number">2.6.1.1. </span>Definition<a class="headerlink" href="#definition" title="Link to this heading">¶</a></h3>
<p>Let us start with a definition.</p>
<div class="proof definition admonition" id="definition-0">
<p class="admonition-title"><span class="caption-number">Definition 2.3 </span> (Signed distance function)</p>
<section class="definition-content" id="proof-content">
<p>Let <span class="math notranslate nohighlight">\(\Omega\)</span> be a bounded Lipschitz domain in <span class="math notranslate nohighlight">\(\R^d\)</span>. The signed distance function <span class="math notranslate nohighlight">\(d_\Omega : \R^d \to \R\)</span> to <span class="math notranslate nohighlight">\(\Omega\)</span> is defined by:</p>
<p><div class="math notranslate nohighlight">
\[\begin{split}\forall \x \in \R^d, \quad d_{\Omega}(\x) =
\left\{\begin{array}{cl}
- d(\x, \partial\Omega) &amp; \text{if } \x \in \Omega,\\
0 &amp; \text{if } \x \in \partial\Omega,\\
d(\x, \partial\Omega) &amp; \text{if } \x \in \R^d\setminus\overline{\Omega},\\
\end{array}
\right.
\end{split}\]</div>
</p>
<p>where <span class="math notranslate nohighlight">\(d(\x,\partial\Omega) = \min\limits_{\y \in \partial \Omega} \lvert \x - \y \lvert\)</span> is the usual Euclidean distance from <span class="math notranslate nohighlight">\(\x\)</span> to <span class="math notranslate nohighlight">\(\partial\Omega\)</span>.</p>
</section>
</div><figure class="align-default" id="id2">
<span id="fig-2lsfunc"></span><a class="reference internal image-reference" href="../_images/2lsfunc.png"><img alt="../_images/2lsfunc.png" src="../_images/2lsfunc.png" style="width: 696.0px; height: 234.0px;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 2.14 </span><span class="caption-text">Two different Level Set functions for the interval <span class="math notranslate nohighlight">\(\Omega = (0,1)\)</span> in <span class="math notranslate nohighlight">\(\R\)</span>. The signed distance function <span class="math notranslate nohighlight">\(d_\Omega\)</span> (on the right) has unit derivative wherever it is defined.</span><a class="headerlink" href="#id2" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The signed distance function <span class="math notranslate nohighlight">\(d_\Omega\)</span> is often preferred over any other Level Set function for <span class="math notranslate nohighlight">\(\Omega\)</span>, owing to its unique features:</p>
<blockquote>
<div><ul>
<li><p>It appraises how far a point <span class="math notranslate nohighlight">\(\x\in D\)</span> is from <span class="math notranslate nohighlight">\(\Omega\)</span>, and not only whether it belongs to <span class="math notranslate nohighlight">\(\Omega\)</span> or <span class="math notranslate nohighlight">\(D \setminus \overline\Omega\)</span>.</p></li>
<li><p>It has uniform variations through space, which is a key ingredient in the stability of numerical frameworks based on the Level Set Method. It can indeed be proved that <span class="math notranslate nohighlight">\(d_\Omega\)</span> is differentiable almost everywhere in <span class="math notranslate nohighlight">\(D\)</span> and that its gradient has unit norm wherever this makes sense:</p>
<div class="math notranslate nohighlight" id="equation-eq-distgrad1">
<span class="eqno">(2.13)<a class="headerlink" href="#equation-eq-distgrad1" title="Link to this equation">¶</a></span>\[\lvert\nabla d _\Omega(\x) \lvert = 1 \text{ for a.e. } \x \in D.\]</div>
</li>
<li><p>Its calculation can be realized by very efficient algorithms, such as the celebrated Fast Marching Method.</p></li>
</ul>
</div></blockquote>
</section>
<section id="numerical-calculation-of-the-signed-distance-function">
<h3><span class="section-number">2.6.1.2. </span>Numerical calculation of the signed distance function<a class="headerlink" href="#numerical-calculation-of-the-signed-distance-function" title="Link to this heading">¶</a></h3>
<p>The <span class="math notranslate nohighlight">\(\texttt{FreeFem}\)</span> environment contains handful routines to calculate the signed distance function <span class="math notranslate nohighlight">\(d_\Omega\)</span> to a domain <span class="math notranslate nohighlight">\(\Omega\)</span>, depending on the numerical representation of the latter. As often in this course, we focus on the 2d case. The implementation corresponding to the examples below is available <a class="reference download internal" download="" href="../_downloads/e72395430521162dd6d8f3f9ef74e250/dist.edp"><code class="xref download docutils literal notranslate"><span class="pre">here</span></code></a>.</p>
<p>At first, it often happens that <span class="math notranslate nohighlight">\(\Omega\)</span> is already described by a Level Set function <span class="math notranslate nohighlight">\(\phi\)</span> which is not the signed distance function (see again <a class="reference internal" href="#fig-2lsfunc"><span class="std std-numref">Fig. 2.14</span></a>, left). The following listing shows how to use the built-in function <code class="code docutils literal notranslate"><span class="pre">distance</span></code> in <span class="math notranslate nohighlight">\(\texttt{FreeFem}\)</span> to retrieve <span class="math notranslate nohighlight">\(d_\Omega\)</span> from this datum.</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Include FreeFem distance function */</span>
<span class="cp">load</span><span class="w"> </span><span class="s">&quot;distance&quot;</span>

<span class="p">[...]</span>

<span class="cm">/* Finite Element spaces */</span>
<span class="kt">fespace</span><span class="w"> </span><span class="n">Vh</span><span class="p">(</span><span class="n">Th</span><span class="p">,</span><span class="nc">P1</span><span class="p">);</span>
<span class="n">Vh</span><span class="w"> </span><span class="n">phi</span><span class="p">,</span><span class="n">phi0</span><span class="p">;</span>

<span class="cm">/* phi0 = level set function (not signed distance) for the disk B((x0,y0),R) */</span>
<span class="kt">real</span><span class="w"> </span><span class="n">x0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="p">;</span>
<span class="kt">real</span><span class="w"> </span><span class="nf">y0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="p">;</span>
<span class="kt">real</span><span class="w"> </span><span class="n">R</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mf">0.25</span><span class="p">;</span>

<span class="n">phi0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kr">x</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="kr">y</span><span class="o">-</span><span class="nf">y0</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">R</span><span class="o">^</span><span class="mi">2</span><span class="p">;</span>

<span class="cm">/* phi = signed distance function to the domain defined by the LS function phi0 */</span>
<span class="n">distance</span><span class="p">(</span><span class="n">Th</span><span class="p">,</span><span class="n">phi0</span><span class="p">,</span><span class="n">phi</span><span class="p">[]);</span>
</pre></div>
</div>
<p>Let us now consider the situation where <span class="math notranslate nohighlight">\(\Omega\)</span> arises as a submesh of a mesh <span class="math notranslate nohighlight">\(\calT\)</span> of the computational domain <span class="math notranslate nohighlight">\(D\)</span>, i.e. it is identified as the set of triangles bearing a particular label <span class="math notranslate nohighlight">\(\texttt{REFINT}\)</span>, see <a class="reference internal" href="#fig-distfrommesh"><span class="std std-numref">Fig. 2.15</span></a> (left). The following commands can then be used, which make use of the built-in function <code class="code docutils literal notranslate"><span class="pre">distance</span></code> and of the module <a class="reference download internal" download="" href="../_downloads/37dbfdc78978d499ddfa62dfca0255d8/LStools.idp"><code class="xref download docutils literal notranslate"><span class="pre">Level</span> <span class="pre">Set</span> <span class="pre">toolbox</span></code></a>, see <a class="reference internal" href="#fig-distfrommesh"><span class="std std-numref">Fig. 2.15</span></a> (right) for the result.</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Finite Element spaces */</span>
<span class="kt">fespace</span><span class="w"> </span><span class="nf">Vh</span><span class="p">(</span><span class="n">Th</span><span class="p">,</span><span class="nc">P1</span><span class="p">);</span>
<span class="n">Vh</span><span class="w"> </span><span class="n">phi</span><span class="p">,</span><span class="n">phi0</span><span class="p">;</span>

<span class="cm">/* Include Level Set toolbox */</span>
<span class="cp">include</span><span class="w"> </span><span class="s">&quot;LStools.idp&quot;</span>

<span class="cm">/* Initialization of the signed distance function near the boundary with label REFBORDER</span>
<span class="cm">   sign + in the domain REFINT, sign - in the domain REFEXT */</span>
<span class="n">phi0</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inidist</span><span class="p">(</span><span class="n">REFBORDER</span><span class="p">,</span><span class="n">REFINT</span><span class="p">,</span><span class="n">REFEXT</span><span class="p">);</span>

<span class="cm">/* Extension of this distance with built-in FreeFem function */</span>
<span class="n">distance</span><span class="p">(</span><span class="n">Th</span><span class="p">,</span><span class="n">phi0</span><span class="p">,</span><span class="n">phi</span><span class="p">[]);</span>
</pre></div>
</div>
<figure class="align-default" id="id3">
<span id="fig-distfrommesh"></span><a class="reference internal image-reference" href="../_images/distfrommesh.png"><img alt="../_images/distfrommesh.png" src="../_images/distfrommesh.png" style="width: 970.1999999999999px; height: 480.0px;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 2.15 </span><span class="caption-text">Plot of the signed distance function <span class="math notranslate nohighlight">\(d_\Omega\)</span> to a domain <span class="math notranslate nohighlight">\(\Omega\)</span> represented as a submesh (in blue, on the left) of the computational domain <span class="math notranslate nohighlight">\(D\)</span>.</span><a class="headerlink" href="#id3" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
</section>
<section id="evolution-of-a-domain-by-the-level-set-method">
<h2><span class="section-number">2.6.2. </span>Evolution of a domain by the Level Set method<a class="headerlink" href="#evolution-of-a-domain-by-the-level-set-method" title="Link to this heading">¶</a></h2>
<p>The present section describes how the Level Set Method efficiently allows to track the motion of an evolving domain <span class="math notranslate nohighlight">\(\Omega(t)\)</span> under the effect of a given velocity field <span class="math notranslate nohighlight">\(\bV(t,\x)\)</span>. The mathematical framework attached to evolving surfaces and domains is very intricate, and for simplicity, we keep the discussion at the formal level, referring the reader eager to delve into mathematical details to the monograph <span id="id1">[<a class="reference internal" href="../Generalities/bibliography.html#id10" title="Yoshikazu Giga. Surface evolution equations. Springer, 2006.">Gig06</a>]</span>. Likewise, for simplicity, we temporarily ignore that the evolution of interest take place in a given bounded computational domain <span class="math notranslate nohighlight">\(D\)</span>, and the latter is replace by the whole ambient space <span class="math notranslate nohighlight">\(\R^d\)</span>.</p>
<p>Let us first make the notion of evolving domain a little more precise.</p>
<section id="evolving-domains">
<h3><span class="section-number">2.6.2.1. </span>Evolving domains<a class="headerlink" href="#evolving-domains" title="Link to this heading">¶</a></h3>
<p>The description of the motion of a domain naturally builds on that of motion of an individual point. The underlying mathematical notion is that of characteristic curve.</p>
<div class="proof definition admonition" id="definition-1">
<span id="def-characcurve"></span><p class="admonition-title"><span class="caption-number">Definition 2.4 </span> (Characteristic curve)</p>
<section class="definition-content" id="proof-content">
<p>Let <span class="math notranslate nohighlight">\(\bV(t,\x)\)</span> be a smooth vector field, defined over a time period <span class="math notranslate nohighlight">\((0,T)\)</span> and the physical space <span class="math notranslate nohighlight">\(\R^d\)</span>. The characteristic curve emerging from a point <span class="math notranslate nohighlight">\(\x_0 \in \R^d\)</span> at time <span class="math notranslate nohighlight">\(t_0\)</span> is the solution <span class="math notranslate nohighlight">\(t \to \bX(t,t_0,\x_0)\)</span> to the following ordinary differential equation:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left\{\begin{array}{cl}
\mathring{\bX}(t,t_0,\x_0) = \bV(t,\bX(t,t_0,\x_0)) &amp; \text{for } t \in (0,T),\\
\bX(t_0,t_0,\x_0) = \x_0. &amp;
\end{array}
\right.\end{split}\]</div>
</section>
</div><p>As depicted on <a class="reference internal" href="#fig-characcurve"><span class="std std-numref">Fig. 2.16</span></a>, the mapping <span class="math notranslate nohighlight">\(t \mapsto \bX(t,t_0,\x_0)\)</span> describes the trajectory in time of a particle driven by the velocity field <span class="math notranslate nohighlight">\(\bV\)</span> which is placed at the position <span class="math notranslate nohighlight">\(\x_0\)</span> at time <span class="math notranslate nohighlight">\(t=t_0\)</span>. Characteristic curves play a ubiquitous role in fluid mechanics, for instance, where they account for the motion of fluid particles, as we shall see in <a class="reference internal" href="../Fluid_Mechanics/index_fl.html#sec-fm"><span class="std std-numref">Section 4</span></a>.</p>
<figure class="align-default" id="id4">
<span id="fig-characcurve"></span><a class="reference internal image-reference" href="../_images/characcurv.png"><img alt="../_images/characcurv.png" src="../_images/characcurv.png" style="width: 671.0px; height: 284.0px;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 2.16 </span><span class="caption-text">Characteristic curves of the vector field <span class="math notranslate nohighlight">\(\bV(t,\x)\)</span> emerging from 3 different points <span class="math notranslate nohighlight">\(\x_0\)</span>, <span class="math notranslate nohighlight">\(\x_1\)</span>, <span class="math notranslate nohighlight">\(\x_2\)</span>.</span><a class="headerlink" href="#id4" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>We can now define an evolving domain <span class="math notranslate nohighlight">\(\Omega(t)\)</span> from an initial position <span class="math notranslate nohighlight">\(\Omega(t_0)\)</span> as the set of positions at time <span class="math notranslate nohighlight">\(t\)</span> of the particles lying in <span class="math notranslate nohighlight">\(\Omega(t_0)\)</span> at <span class="math notranslate nohighlight">\(t_0\)</span>, see <a class="reference internal" href="#fig-evoldomain"><span class="std std-numref">Fig. 2.17</span></a></p>
<div class="proof definition admonition" id="definition-2">
<p class="admonition-title"><span class="caption-number">Definition 2.5 </span> (Intuitive definition of an evolving domain)</p>
<section class="definition-content" id="proof-content">
<p>Let <span class="math notranslate nohighlight">\(\Omega_0\)</span> be a domain in <span class="math notranslate nohighlight">\(\R^d\)</span>. The evolving domain <span class="math notranslate nohighlight">\(\Omega(t)\)</span> starting from the position <span class="math notranslate nohighlight">\(\Omega_0\)</span> at <span class="math notranslate nohighlight">\(t_0\)</span> is defined by:</p>
<p><div class="math notranslate nohighlight">
\[\Omega(t) = \Big\{ \bX(t,t_0,\x), \:\: \x \in \Omega_0 \Big\}.\]</div>
</p>
</section>
</div><figure class="align-default" id="id5">
<span id="fig-evoldomain"></span><a class="reference internal image-reference" href="../_images/figdomevol.png"><img alt="../_images/figdomevol.png" src="../_images/figdomevol.png" style="width: 448.2px; height: 274.2px;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 2.17 </span><span class="caption-text">Evolution of a domain <span class="math notranslate nohighlight">\(\Omega(t)\)</span>.</span><a class="headerlink" href="#id5" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="description-of-the-motion-of-a-domain-by-the-level-set-method">
<h3><span class="section-number">2.6.2.2. </span>Description of the motion of a domain by the Level Set Method<a class="headerlink" href="#description-of-the-motion-of-a-domain-by-the-level-set-method" title="Link to this heading">¶</a></h3>
<p>Let us now explain how the time evolution of a domain is accounted for by a level set function.
To this end, let <span class="math notranslate nohighlight">\(\Omega(t)\)</span> be a domain in <span class="math notranslate nohighlight">\(\R^d\)</span>, evolving according to a velocity field <span class="math notranslate nohighlight">\(\bV(t,\x)\)</span> over a time period <span class="math notranslate nohighlight">\((0,T)\)</span>. Let also <span class="math notranslate nohighlight">\(\phi(t,\cdot)\)</span> be a Level Set function for <span class="math notranslate nohighlight">\(\Omega(t)\)</span>, i.e.</p>
<p><div class="math notranslate nohighlight">
\[\begin{split}\forall t \in [0,T], \:\: \forall \x \in \R^d, \quad \left\{\begin{array}{cl}
\phi(t,\x) &lt; 0 &amp; \text{if } \x \in \Omega(t),\\[0.2em]
\phi(t,\x) = 0 &amp; \text{if } \x \in \partial\Omega(t),\\
\phi(t,\x) &gt; 0 &amp; \text{if } \x \in \R^d \setminus \overline{\Omega(t)}.\\
\end{array}\right. \end{split}\]</div>
</p>
<p>Since the boundary of <span class="math notranslate nohighlight">\(\Omega(0)\)</span> is transported onto that of <span class="math notranslate nohighlight">\(\Omega(t)\)</span> by the velocity field <span class="math notranslate nohighlight">\(\bV(t,\x)\)</span>, the above relation for <span class="math notranslate nohighlight">\(\phi(t,\x)\)</span> implies that:</p>
<p><div class="math notranslate nohighlight">
\[\forall t \in (0,T), \:\forall \x \in \partial \Omega(0), \quad \phi(t,\bX(t,0,\x)) = 0. \]</div>
</p>
<p>Hence, taking derivatives with respect to time in the above equality, we obtain:</p>
<p><div class="math notranslate nohighlight">
\[\forall t \in (0,T), \:\forall \x \in \partial \Omega(0), \quad \frac{\partial \phi}{\partial t}(t,\bX(t,0,\x)) + \frac{\partial \bX}{\partial t}(t,0,\bX(t,0,\x)) \cdot \nabla \phi(t,\bX(t,0,\x)) = 0. \]</div>
</p>
<p>Since the instantaneous velocity <span class="math notranslate nohighlight">\(\frac{\partial \bX}{\partial t}\)</span> of the particles is <span class="math notranslate nohighlight">\(\bV\)</span>, this rewrites:</p>
<div class="math notranslate nohighlight" id="equation-eq-lsadv1">
<span class="eqno">(2.14)<a class="headerlink" href="#equation-eq-lsadv1" title="Link to this equation">¶</a></span>\[\forall t \in (0,T), \:\forall \x \in \partial\Omega(t), \quad \frac{\partial \phi}{\partial t}(t,\x) + \bV(t,\x) \cdot \nabla \phi(t,\x) = 0. $$\]</div>
<p>We now impose this relation at all points in space, to obtain the so-called Level Set advection equation:</p>
<div class="math notranslate nohighlight" id="equation-eq-lsadv2">
<span class="eqno">(2.15)<a class="headerlink" href="#equation-eq-lsadv2" title="Link to this equation">¶</a></span>\[\forall t \in (0,T), \:\forall \x \in \R^d, \quad \frac{\partial \phi}{\partial t}(t,\x) + \bV(t,\x) \cdot \nabla \phi(t,\x) = 0.\]</div>
<p>This equation should be completed by a suitable initial condition, such as:
<div class="math notranslate nohighlight">
\[\forall \x \in \R^d, \quad \phi(0,\x) = \phi_0(\x), \text{ where } \phi_0 \text{ is one Level Set function for the initial domain }\Omega_0.\]</div>
</p>
<p>This simple, formal derivation reveals a key appealing feature of the Level Set framework: the (difficult) motion of the domain <span class="math notranslate nohighlight">\(\Omega(t)\)</span> is encoded into an advection-like equation for an associated Level Set function, which can be solved on a fixed mesh of the computational domain <span class="math notranslate nohighlight">\(D\)</span>.</p>
<p>Let us consider two educative examples of evolving domains.</p>
<div class="proof example admonition" id="example-3">
<span id="ex-flamemodel"></span><p class="admonition-title"><span class="caption-number">Example 2.2 </span> (Flame propagation model)</p>
<section class="example-content" id="proof-content">
<p>In this example, the domain <span class="math notranslate nohighlight">\(\Omega(t) \subset \R^2\)</span> represents a burnt region of the ground. In the absence of slope or wind, the flame front <span class="math notranslate nohighlight">\(\Omega(t)\)</span> expands in the normal direction with a constant velocity <span class="math notranslate nohighlight">\(c &gt;0\)</span>. The velocity field driving the motion of <span class="math notranslate nohighlight">\(\Omega(t)\)</span> is:
<div class="math notranslate nohighlight">
\[\bV(t,\x) = c \n_{\Omega(t)}(\x), \]</div>

where <span class="math notranslate nohighlight">\(\n_{\Omega(t)}(\x) = \frac{\nabla\phi(t,\x)}{\lvert \nabla\phi(t,\x)\lvert}\)</span> is the unit normal vector to <span class="math notranslate nohighlight">\(\partial \Omega(t)\)</span>, pointing outward <span class="math notranslate nohighlight">\(\Omega(t)\)</span>. The Level Set equation <a class="reference internal" href="#equation-eq-lsadv2">(2.15)</a> then becomes:
<div class="math notranslate nohighlight">
\[\frac{\partial \phi}{\partial t}(t,\x) + c\lvert \nabla \phi(t,\x)\lvert = 0.\]</div>

The dynamics of this evolution is sketched in <a class="reference internal" href="#fig-flamprop"><span class="std std-numref">Fig. 2.18</span></a>.</p>
</section>
</div><figure class="align-default" id="id6">
<span id="fig-flamprop"></span><a class="reference internal image-reference" href="../_images/flamprop.png"><img alt="../_images/flamprop.png" src="../_images/flamprop.png" style="width: 964.8px; height: 266.4px;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 2.18 </span><span class="caption-text">Evolution of a domain <span class="math notranslate nohighlight">\(\Omega(t)\)</span> in the flame propagation model.</span><a class="headerlink" href="#id6" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<div class="proof example admonition" id="example-4">
<span id="ex-mcf"></span><p class="admonition-title"><span class="caption-number">Example 2.3 </span> (Mean curvature flow)</p>
<section class="example-content" id="proof-content">
<p>The mean curvature flow features a deformation of the boundary of the domain <span class="math notranslate nohighlight">\(\Omega(t)\)</span> which is opposite to its curvature, i.e.
<div class="math notranslate nohighlight">
\[\bV(t,\x) = \kappa_{\Omega(t)}(\x) \n_{\Omega(t)}(\x), \text{ where } \kappa_{\Omega(t)}(\x) = \dv\left(\frac{ \nabla \phi(t,\x) }{\lvert  \nabla \phi(t,\x)   \lvert } \right) \text{ is the mean curvature of } \partial\Omega(t).\]</div>

Loosely speaking, this motion has the following behavior:</p>
<blockquote>
<div><ul class="simple">
<li><p>The regions where <span class="math notranslate nohighlight">\(\Omega(t)\)</span> is convex (i.e. <span class="math notranslate nohighlight">\(\kappa_{\Omega(t)}(\x) &gt; 0\)</span>) get resorbed;</p></li>
<li><p>The regions where <span class="math notranslate nohighlight">\(\Omega(t)\)</span> is concave (i.e. <span class="math notranslate nohighlight">\(\kappa_{\Omega(t)}(\x) &lt; 0\)</span>) are corked,</p></li>
</ul>
</div></blockquote>
<p>see <a class="reference internal" href="#fig-mcf"><span class="std std-numref">Fig. 2.19</span></a> for an illustration. In this setting, the Level Set equation <a class="reference internal" href="#equation-eq-lsadv2">(2.15)</a> reads:
<div class="math notranslate nohighlight">
\[\frac{\partial \phi}{\partial t}(t,\x) + \dv\left(\frac{ \nabla \phi(t,\x) }{\lvert  \nabla \phi(t,\x)   \lvert }\right)\lvert \nabla \phi(t,\x)\lvert = 0.\]</div>
</p>
</section>
</div><figure class="align-default" id="id7">
<span id="fig-mcf"></span><a class="reference internal image-reference" href="../_images/mcf.png"><img alt="../_images/mcf.png" src="../_images/mcf.png" style="width: 963.0px; height: 231.6px;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 2.19 </span><span class="caption-text">Evolution of a domain <span class="math notranslate nohighlight">\(\Omega(t)\)</span> via the mean curvature flow.</span><a class="headerlink" href="#id7" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<div class="proof remark admonition" id="remark-5">
<span id="rem-vells"></span><p class="admonition-title"><span class="caption-number">Remark 2.3 </span></p>
<section class="remark-content" id="proof-content">
<ul>
<li><p>The passage from the relation <a class="reference internal" href="#equation-eq-lsadv1">(2.14)</a>, which holds only on <span class="math notranslate nohighlight">\(\partial\Omega(t)\)</span>, to <a class="reference internal" href="#equation-eq-lsadv2">(2.15)</a>, which is imposed on the whole space <span class="math notranslate nohighlight">\(\R^d\)</span>, actually amounts to imposing that all the isolines of the Level Set function <span class="math notranslate nohighlight">\(\phi\)</span> (and not only the <span class="math notranslate nohighlight">\(0\)</span> isoline) are deformed according to the velocity field <span class="math notranslate nohighlight">\(\bV(t,\x)\)</span>.</p></li>
<li><p>In general, the Level Set equation <a class="reference internal" href="#equation-eq-lsadv2">(2.15)</a> is not a &quot;true&quot; advection equation, since the velocity field <span class="math notranslate nohighlight">\(\bV(t,\x)\)</span> usually depends on the domain <span class="math notranslate nohighlight">\(\Omega(t)\)</span> (and so, depends on <span class="math notranslate nohighlight">\(\phi(t,\x)\)</span>), for instance:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\bV(t,\x)\)</span> may depend on the normal vector or the mean curvature of <span class="math notranslate nohighlight">\(\partial \Omega(t)\)</span>, as in <a class="reference internal" href="#ex-flamemodel"><span class="std std-numref">example 2.2</span></a> or <a class="reference internal" href="#ex-mcf"><span class="std std-numref">example 2.3</span></a>;</p></li>
<li><p>In even more intricate situations, it may be prescribed by the solution to physical boundary-value problems posed on <span class="math notranslate nohighlight">\(\Omega(t)\)</span>: the elasticity system when <span class="math notranslate nohighlight">\(\Omega(t)\)</span> stands for a mechanical structure, the Stokes or Navier-Stokes equations when it represents a fluid domain, etc.</p></li>
</ul>
</li>
<li><p>In the particularly simple situation where <span class="math notranslate nohighlight">\(\bV(t,\x)\)</span> is externally given, i.e. independently of <span class="math notranslate nohighlight">\(\Omega(t)\)</span>, then <a class="reference internal" href="#equation-eq-lsadv2">(2.15)</a> boils down to a &quot;true&quot;, linear advection equation.</p></li>
<li><p>Another situation of interest is that where <span class="math notranslate nohighlight">\(\bV(t,\x)\)</span> is consistently oriented in the direction of the normal vector <span class="math notranslate nohighlight">\(\n_{\Omega(t)}(\x)\)</span>, with a (scalar) normal velocity <span class="math notranslate nohighlight">\(v(t,\x)\)</span> independent of <span class="math notranslate nohighlight">\(\Omega(t)\)</span>, that is:</p>
<div class="math notranslate nohighlight">
\[\bV(t,\x) = v(t,\x) n_{\Omega(t)} (\x).\]</div>
<p>Then, the Level Set equation <a class="reference internal" href="#equation-eq-lsadv2">(2.15)</a> takes the form of a (non linear) Hamilton-Jacobi equation:
<div class="math notranslate nohighlight">
\[\frac{\partial \phi}{\partial t}(t,\x) + v(t,\x) \lvert \nabla \phi(t,\x)\lvert = 0.\]</div>
</p>
</li>
<li><p>The above argument is only formal, as it is only valid when <span class="math notranslate nohighlight">\(\Omega(t)\)</span>, <span class="math notranslate nohighlight">\(\bV(t,\x)\)</span> and <span class="math notranslate nohighlight">\(\phi(t,\x)\)</span> are smooth enough over the considered time interval. Actually, the definition of an involving domain is different when singularities occur, and it relies on the intricate mathematical notion of viscosity solutions for Hamilton-Jacobi equations.</p></li>
</ul>
</section>
</div></section>
<section id="numerical-resolution-of-the-advection-equation-in-texttt-freefem">
<span id="sec-lsadv"></span><h3><span class="section-number">2.6.2.3. </span>Numerical resolution of the advection equation in <span class="math notranslate nohighlight">\(\texttt{FreeFem}\)</span><a class="headerlink" href="#numerical-resolution-of-the-advection-equation-in-texttt-freefem" title="Link to this heading">¶</a></h3>
<p>The <span class="math notranslate nohighlight">\(\texttt{FreeFem}\)</span> environment provides useful commands to solve the Level Set evolution equation <a class="reference internal" href="#equation-eq-lsadv2">(2.15)</a>.</p>
<p>Let us first consider the particular case where the velocity field does not depend on <span class="math notranslate nohighlight">\(\Omega(t)\)</span>, not even on time: <span class="math notranslate nohighlight">\(\bV \equiv \bV(\x)\)</span>.
The equation <a class="reference internal" href="#equation-eq-lsadv2">(2.15)</a> is then a &quot;true&quot; advection equation:</p>
<div class="math notranslate nohighlight" id="equation-eq-trueadv">
<span class="eqno">(2.16)<a class="headerlink" href="#equation-eq-trueadv" title="Link to this equation">¶</a></span>\[\begin{split}\left\{
\begin{array}{cl}
\frac{\partial\phi}{\partial t}(t,\x) + \bV(\x) \cdot \nabla \phi(t,\x) =0 &amp; \text{for } t \in (0,T), \: \x \in \R^d,\\
\phi(0,\x) = \phi_0(\x) &amp; \text{for } \x \in \R^d.
\end{array}
\right.\end{split}\]</div>
<p>This special case is particularly handful, as the exact solution to <a class="reference internal" href="#equation-eq-trueadv">(2.16)</a> is given by the (backward) method of characteristics:</p>
<div class="math notranslate nohighlight" id="equation-eq-soladvcharac">
<span class="eqno">(2.17)<a class="headerlink" href="#equation-eq-soladvcharac" title="Link to this equation">¶</a></span>\[\forall t\in (0,T), \: \x \in \R^d, \quad \phi(t,\x) = \phi_0(\bX(0,t,\x)).\]</div>
<p>In this expression <span class="math notranslate nohighlight">\(s \mapsto \bX(s,t,\x)\)</span> is the characteristic curve emerging from <span class="math notranslate nohighlight">\(\x\)</span> at time <span class="math notranslate nohighlight">\(t\)</span>, as defined in <a class="reference internal" href="#def-characcurve"><span class="std std-numref">definition 2.4</span></a>.
Despite its technical aspect, the above expression is very intuitive: the value of <span class="math notranslate nohighlight">\(\phi\)</span> at time <span class="math notranslate nohighlight">\(t\)</span> and point <span class="math notranslate nohighlight">\(\x\)</span> is the value of the initial datum <span class="math notranslate nohighlight">\(\phi_0\)</span> at the initial position <span class="math notranslate nohighlight">\(\bX(0,t,\x)\)</span> of the particle lying at <span class="math notranslate nohighlight">\(\x\)</span> at time <span class="math notranslate nohighlight">\(t\)</span> (the &quot;foot&quot; of the characteristic curve); in other terms, <span class="math notranslate nohighlight">\(\phi_0\)</span> is transported along the velocity field <span class="math notranslate nohighlight">\(\bV(\x)\)</span>.</p>
<p>In practice, the formula <a class="reference internal" href="#equation-eq-soladvcharac">(2.17)</a> can be used to calculate <span class="math notranslate nohighlight">\(\phi(t,\x)\)</span>: this essentially demands to solve the ordinary differential equations for <span class="math notranslate nohighlight">\(\bX(s,t,\x)\)</span>, e.g. by a Runge-Kutta scheme. The  <code class="code docutils literal notranslate"><span class="pre">convect</span></code> command from <span class="math notranslate nohighlight">\(\texttt{FreeFem}\)</span> conveniently allows to handle the operation <a class="reference internal" href="#equation-eq-soladvcharac">(2.17)</a>, as exemplified by the following listing:</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Finite Element spaces and functions */</span>
<span class="kt">fespace</span><span class="w"> </span><span class="nf">Vh</span><span class="p">(</span><span class="n">Th</span><span class="p">,</span><span class="nc">P1</span><span class="p">);</span>
<span class="n">Vh</span><span class="w"> </span><span class="n">Vx</span><span class="p">,</span><span class="n">Vy</span><span class="p">,</span><span class="n">phi0</span><span class="p">,</span><span class="n">phinew</span><span class="p">;</span>

<span class="cm">/* Length of the advection period */</span>
<span class="kt">real</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.1</span><span class="p">;</span>

<span class="cm">/* Backward characteristic method along the vector field (Vx,Vy): phinew(x) = phi(\X(0,T,x)) */</span>
<span class="n">phinew</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">convect</span><span class="p">([</span><span class="n">Vx</span><span class="p">,</span><span class="n">Vy</span><span class="p">],</span><span class="o">-</span><span class="n">T</span><span class="p">,</span><span class="n">phi0</span><span class="p">);</span>
</pre></div>
</div>
<p>The general case where the velocity field <span class="math notranslate nohighlight">\(\bV(t,\x)\)</span> depends on time <span class="math notranslate nohighlight">\(t\)</span> (and on <span class="math notranslate nohighlight">\(\Omega(t)\)</span>) is usually reduced to a series of computations of the above type;
the total time period <span class="math notranslate nohighlight">\((0,T)\)</span> is decomposed into a series of snapshots
<div class="math notranslate nohighlight">
\[t^n = n \Delta t, \:\: t=0,\ldots,N := \frac{T}{\Delta t}, \text{ where }\Delta t &gt; 0 \text{ is a small enough time step}.\]</div>

The velocity field <span class="math notranslate nohighlight">\(\bV(t,\x)\)</span> is then &quot;frozen&quot; on each interval <span class="math notranslate nohighlight">\((t^n,t^{n+1})\)</span>:
<div class="math notranslate nohighlight">
\[\forall t \in (t^n,t^{n+1}), \quad \bV(t,\x) \approx \bV^n(\x) = \bV(t^n,\x).\]</div>

Depending on the nature of <span class="math notranslate nohighlight">\(\bV(t,\x)\)</span>, this operation may involve the calculation of geometric quantities attached to <span class="math notranslate nohighlight">\(\Omega(t^n)\)</span> (its normal vector, mean curvature, etc.), or it may require to solve physical boundary-value problems on this domain, see <a class="reference internal" href="#rem-vells"><span class="std std-numref">remark 2.3</span></a>.</p>
</section>
</section>
<section id="miscellaneous-operations-on-implicit-domains">
<h2><span class="section-number">2.6.3. </span>Miscellaneous operations on implicit domains<a class="headerlink" href="#miscellaneous-operations-on-implicit-domains" title="Link to this heading">¶</a></h2>
<p>In this section, we present two numerical operations based on the datum of a domain <span class="math notranslate nohighlight">\(\Omega \subset \R^d\)</span> as a Level Set function <span class="math notranslate nohighlight">\(\phi : D \to \R\)</span> that often come in handy. Again, for simplicity, the discussion stays at the formal level.</p>
<section id="evaluation-of-integrals-on-omega-or-gamma">
<h3><span class="section-number">2.6.3.1. </span>Evaluation of integrals on <span class="math notranslate nohighlight">\(\Omega\)</span> or <span class="math notranslate nohighlight">\(\Gamma\)</span><a class="headerlink" href="#evaluation-of-integrals-on-omega-or-gamma" title="Link to this heading">¶</a></h3>
<p>Given a smooth function <span class="math notranslate nohighlight">\(f: \mathbb{R}^d \rightarrow \R\)</span>, we wish to calculate the volume integral</p>
<div class="math notranslate nohighlight" id="equation-eq-volintls">
<span class="eqno">(2.18)<a class="headerlink" href="#equation-eq-volintls" title="Link to this equation">¶</a></span>\[I := \int_\Omega f(\x)\:\d \x.\]</div>
<p>To achieve this, let us rewrite:</p>
<div class="math notranslate nohighlight" id="equation-eq-characls">
<span class="eqno">(2.19)<a class="headerlink" href="#equation-eq-characls" title="Link to this equation">¶</a></span>\[\begin{split}I = \int_{\R^d} f(\x) \chi_\Omega(\x) \:\d \x , \text{ where } \chi_\Omega \text{ is the characteristic function of } \Omega: \: \chi_\Omega(\x)=
\left\{\begin{array}{cl}
1&amp; \text{if } \x \in \Omega, \\
0 &amp; \text{otherwise}. \end{array}\right.\end{split}\]</div>
<p>Let us now remark that <span class="math notranslate nohighlight">\(\chi_\Omega\)</span> can be expressed in terms of the Level Set function <span class="math notranslate nohighlight">\(\phi\)</span> as:</p>
<div class="math notranslate nohighlight" id="equation-eq-approxchiom">
<span class="eqno">(2.20)<a class="headerlink" href="#equation-eq-approxchiom" title="Link to this equation">¶</a></span>\[\begin{split}\chi_\Omega(\x) = H(\phi(\x)), \text{ where } H: \R \to \R \text{ is defined by } H(t) = \left\{
\begin{array}{cl}
1 &amp; \text{if } t &lt; 0, \\
0 &amp; \text{otherwise}.
\end{array}
\right.\end{split}\]</div>
<p>An approximation of <span class="math notranslate nohighlight">\(\chi_\Omega\)</span> is thus given by:
<div class="math notranslate nohighlight">
\[\chi_\Omega(\x) \approx H_{\e}(\phi(\x)), \text{ where } H_{\e}(t):= \frac{1}{2}\left(1 - \frac{t}{\sqrt{t^2 + \e^2}} \right),\]</div>

and <span class="math notranslate nohighlight">\(\e \ll 1\)</span> is a &quot;small&quot; parameter, see <a class="reference internal" href="#fig-heps"><span class="std std-numref">Fig. 2.20</span></a> for an illustration.</p>
<p>Hence, the volume integral <span class="math notranslate nohighlight">\(I\)</span> can be approximated as:
<div class="math notranslate nohighlight">
\[I \approx \int_{\mathbb{R}^d}{f(\x) H_{\e}(\phi(\x))\:\d \x}.\]</div>
</p>
<figure class="align-default" id="id8">
<span id="fig-heps"></span><a class="reference internal image-reference" href="../_images/Heps.png"><img alt="../_images/Heps.png" src="../_images/Heps.png" style="width: 459.0px; height: 167.0px;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 2.20 </span><span class="caption-text">Approximation <span class="math notranslate nohighlight">\(H_{\e}\)</span> (in red) of the characteristic function of <span class="math notranslate nohighlight">\((-\infty,0)\)</span> (in blue)</span><a class="headerlink" href="#id8" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="calculation-of-an-integral-over-partialomega">
<h3><span class="section-number">2.6.3.2. </span>Calculation of an integral over <span class="math notranslate nohighlight">\(\partial\Omega\)</span><a class="headerlink" href="#calculation-of-an-integral-over-partialomega" title="Link to this heading">¶</a></h3>
<p>Let <span class="math notranslate nohighlight">\(g: \R^d \rightarrow \R\)</span> be a smooth function; we now wish to calculate the boundary integral
<div class="math notranslate nohighlight">
\[J = \int_\Gamma{g(\x)\:\d s(\x)}.\]</div>

This task is a little bit more intricate than the calculation of volume integrals, of the form <a class="reference internal" href="#equation-eq-volintls">(2.18)</a>.
To achieve this, let us rewrite:
<div class="math notranslate nohighlight">
\[J = \langle \delta_{\partial \Omega}, g \rangle, \text{ where }\delta_{\partial \Omega} \text{ is the integration measure on }\partial \Omega.\]</div>

We now invoke the following identity, which uses the language of the <a class="reference internal" href="../Appendix/appPDE.html#app-distrib"><span class="std std-ref">theory of distributions</span></a>:
<div class="math notranslate nohighlight">
\[\frac{\partial \chi_\Omega}{\partial n} = -\delta_{\partial \Omega}. \]</div>

Intuitively, the above left-hand side features the characteristic function <span class="math notranslate nohighlight">\(\chi_\Omega\)</span> of <span class="math notranslate nohighlight">\(\Omega\)</span>, see <a class="reference internal" href="#equation-eq-characls">(2.19)</a>. This function is constant inside <span class="math notranslate nohighlight">\(\Omega\)</span> and <span class="math notranslate nohighlight">\(\R^d \setminus \overline\Omega\)</span> (and so its derivative vanishes on these sets), and its values jump from <span class="math notranslate nohighlight">\(1\)</span> to <span class="math notranslate nohighlight">\(0\)</span> across <span class="math notranslate nohighlight">\(\partial \Omega\)</span>, so that, formally, its normal derivative equals <span class="math notranslate nohighlight">\(-1\)</span> on there. Hence, up to the sign, <span class="math notranslate nohighlight">\(\frac{\partial \Omega}{\partial n}\)</span> coincides with <span class="math notranslate nohighlight">\(\delta_{\partial \Omega}\)</span>.</p>
<p>We now use this identity to approximate the integration on <span class="math notranslate nohighlight">\(\partial \Omega\)</span>:
<div class="math notranslate nohighlight">
\[\delta_\Gamma   \approx -\frac{\partial}{\partial n}(H_{\e}(\phi)),\]</div>

where <span class="math notranslate nohighlight">\(H_\e\)</span> is the function introduced in <a class="reference internal" href="#equation-eq-characls">(2.19)</a>.
The desired approximation of <span class="math notranslate nohighlight">\(J\)</span> is now:
<div class="math notranslate nohighlight">
\[J \approx - \int_{\mathbb{R}^d}{\frac{\partial}{\partial n}(H_{\e}(\phi(\x)))\: g(\x) \:\d \x}.\]</div>
</p>
</section>
</section>
<section id="implementation-of-the-level-set-method">
<h2><span class="section-number">2.6.4. </span>Implementation of the Level Set Method<a class="headerlink" href="#implementation-of-the-level-set-method" title="Link to this heading">¶</a></h2>
<p>Building on the individual ingredients introduced previously, this section presents a generic numerical strategy for tracking the motion of a domain <span class="math notranslate nohighlight">\(\Omega(t)\)</span>, evolving from an initial configuration <span class="math notranslate nohighlight">\(\Omega_0\)</span> according to a velocity field <span class="math notranslate nohighlight">\(\bV(t,\x)\)</span>.</p>
<section id="algorithm-sketch">
<h3><span class="section-number">2.6.4.1. </span>Algorithm sketch<a class="headerlink" href="#algorithm-sketch" title="Link to this heading">¶</a></h3>
<p>Let <span class="math notranslate nohighlight">\(\calT\)</span> be a fixed mesh of the computational domain <span class="math notranslate nohighlight">\(D\)</span>, and let
<div class="math notranslate nohighlight">
\[0 = t^0 &lt; t^1 &lt; \ldots &lt; t^N = T, \quad t^n = n\Delta t, \text{ for a suitably small time step } \Delta t,\]</div>

be a subdivision of the time interval <span class="math notranslate nohighlight">\((0,T)\)</span>.</p>
<p>The following procedure calculates snapshots <span class="math notranslate nohighlight">\(\phi^n(\x) = \phi(t^n,\x)\)</span> of a Level Set function <span class="math notranslate nohighlight">\(\phi(t,\x)\)</span> for the evolving domain <span class="math notranslate nohighlight">\(\Omega(t)\)</span>.</p>
<ul>
<li><p><strong>Initialization:</strong> <span class="math notranslate nohighlight">\(\phi^0(\x)\)</span> is one Level Set function <span class="math notranslate nohighlight">\(\phi_0(\x)\)</span> for the initial domain <span class="math notranslate nohighlight">\(\Omega_0\)</span>, see <a class="reference internal" href="#sec-distls"><span class="std std-numref">Section 2.6.1</span></a> about the generation of such functions, depending on the input format for <span class="math notranslate nohighlight">\(\Omega_0\)</span>.</p></li>
<li><p><strong>For <span class="math notranslate nohighlight">\(n=0,\ldots,N-1\)</span></strong>,</p>
<ul>
<li><p>Freeze the velocity field over the time period <span class="math notranslate nohighlight">\((t^n,t^{n+1})\)</span>:
<div class="math notranslate nohighlight">
\[\forall t \in (t^n,t^{n+1}), \quad \bV(t,\x) \approx \bV^n(\x) = \bV(t^n,\x);\]</div>

recall that this operation may involve geometric or Finite Element calculations on <span class="math notranslate nohighlight">\(\Omega(t^n)\)</span>.</p></li>
<li><p>Solve the advection equation</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left\{
\begin{array}{cl}
\frac{\partial\phi}{\partial t}(t,\x) + \bV^n(\x) \cdot \nabla \phi(t,\x) =0 &amp; \text{for } t \in (t^n,t^{n+1}), \: \x \in D,\\
\phi(t^n,\x) = \phi^n(\x) &amp; \text{for } \x \in D,
\end{array}
\right.\end{split}\]</div>
<p>thanks to the method introduced in <a class="reference internal" href="#sec-lsadv"><span class="std std-numref">Section 2.6.2.3</span></a>.</p>
</li>
<li><p><em>(Optionally, once every 4, 5 iteration)</em> Replace the obtained Level Set function <span class="math notranslate nohighlight">\(\phi^{n+1}(\x)\)</span> for <span class="math notranslate nohighlight">\(\Omega(t^{n+1})\)</span> with the signed distance function <span class="math notranslate nohighlight">\(d_{\Omega(t^{n+1})}(\x)\)</span> to <span class="math notranslate nohighlight">\(\Omega(t^{n+1})\)</span>, thanks to the method presented in <a class="reference internal" href="#sec-distls"><span class="std std-numref">Section 2.6.1</span></a>.</p></li>
</ul>
</li>
</ul>
<div class="proof remark admonition" id="remark-6">
<p class="admonition-title"><span class="caption-number">Remark 2.4 </span></p>
<section class="remark-content" id="proof-content">
<p>As highlighted in <a class="reference internal" href="#sec-distls"><span class="std std-numref">Section 2.6.1</span></a>, the numerical stability of the Level Set Method is significantly improved when the considered Level Set functions are &quot;close&quot; to being signed distance functions, whose variations are uniform over space, see <a class="reference internal" href="#equation-eq-distgrad1">(2.13)</a>. In the course of an iterative evolution process as in above, it is customary to periodically insert a so-called redistancing step, aimed to restore this property.</p>
</section>
</div></section>
<section id="an-implementation-example">
<h3><span class="section-number">2.6.4.2. </span>An implementation example<a class="headerlink" href="#an-implementation-example" title="Link to this heading">¶</a></h3>
<p>In order to illustrate the previous material, let us simulate the evolution of a domain <span class="math notranslate nohighlight">\(\Omega(t)\)</span> under the effect of an analytical vector field <span class="math notranslate nohighlight">\(\bV(t,\x)\)</span>. This example is admittedly artifical; we shall see more realistic usages of the Level Set Method in the context of evolving fluid interfaces, in <a class="reference internal" href="../Fluid_Mechanics/evolving.html#sec-dynfluid"><span class="std std-numref">Section 4.5</span></a>, and in shape optimization, see <a class="reference internal" href="../Optimal_design/geometricLS.html#sec-sols"><span class="std std-numref">Section 5.3</span></a>.</p>
<p>Let <span class="math notranslate nohighlight">\(D\)</span> be the unit square in <span class="math notranslate nohighlight">\(\R^2\)</span>, and let the initial domain <span class="math notranslate nohighlight">\(\Omega(0)\)</span> be the disk with center <span class="math notranslate nohighlight">\((x_0,x_1) = (0.5,0.75)\)</span> and radius <span class="math notranslate nohighlight">\(0.15\)</span>. We aim to capture the evolution of <span class="math notranslate nohighlight">\(\Omega(t)\)</span> under the effect of the vector field</p>
<p><div class="math notranslate nohighlight">
\[\begin{split}\forall t \in (0,T_{\text{max}}), \: \x \in D, \quad \bV(t,\x) = \left(\begin{array}{c}
-\sin^2(\pi x_0)\sin(2\pi x_1) \cos(\pi t/T_{\text{max}})\\
\sin^2(\pi x_1) \sin(2\pi x_0) \cos(\pi t/T_{\text{max}})
\end{array}\right).\end{split}\]</div>
</p>
<p>Loosely speaking, <span class="math notranslate nohighlight">\(\bV(t,\x)\)</span> induces a vortex which stretches the domain from <span class="math notranslate nohighlight">\(0\)</span> to <span class="math notranslate nohighlight">\(T_{\text{max}}/2\)</span> and unstretches it back to its initial configuration at the final time <span class="math notranslate nohighlight">\(T_{\text{max}}\)</span>.</p>
<div class="admonition-exo admonition">
<p class="admonition-title">Exercise</p>
<p>Implement the numerical simulation of the motion of <span class="math notranslate nohighlight">\(\Omega(t)\)</span> for a final time <span class="math notranslate nohighlight">\(T_{\text{max}}=4\)</span>.</p>
<p><em>Hint: To carefully track the extreme deformation undergone by the domain, a mesh adaptation procedure is required, see</em> <a class="reference internal" href="../Generalities/mesh.html#sec-amr"><span class="std std-numref">Section 1.6.2</span></a> <em>about this issue.</em></p>
</div>
<p>The code associated to this simulation is contained in the file <a class="reference download internal" download="" href="../_downloads/811926a256c0fe6e9f27a37fcdd71cc7/evol.edp"><code class="xref download docutils literal notranslate"><span class="pre">evol.edp</span></code></a>. It makes use of the functions contained in the <a class="reference download internal" download="" href="../_downloads/37dbfdc78978d499ddfa62dfca0255d8/LStools.idp"><code class="xref download docutils literal notranslate"><span class="pre">Level</span> <span class="pre">Set</span> <span class="pre">toolbox</span></code></a>. The numerical result is depicted on <a class="reference internal" href="#fig-vortres1"><span class="std std-numref">Fig. 2.21</span></a> and <a class="reference internal" href="#fig-vortres2"><span class="std std-numref">Fig. 2.22</span></a>.</p>
<figure class="align-default" id="id9">
<span id="fig-vortres1"></span><img alt="../_images/vortexres.png" src="../_images/vortexres.png" />
<figcaption>
<p><span class="caption-number">Fig. 2.21 </span><span class="caption-text">A few iterates in the simulation of the time-reversed vortex flow</span><a class="headerlink" href="#id9" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-default" id="id10">
<span id="fig-vortres2"></span><a class="reference internal image-reference" href="../_images/vortex.gif"><img alt="../_images/vortex.gif" src="../_images/vortex.gif" style="width: 360.0px; height: 360.0px;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 2.22 </span><span class="caption-text">Evolution of a disk under the time-reversed vortex flow</span><a class="headerlink" href="#id10" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index.html">
    <img class="logo" src="../_static/falcmill.png" alt="Logo" />
    
  </a>
</p>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../Generalities/index_gen.html">1. Generalities</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index_adv.html">2. Advanced features</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="imgmesh.html">2.1. Meshing images</a></li>
<li class="toctree-l2"><a class="reference internal" href="curvature.html">2.2. Curvature</a></li>
<li class="toctree-l2"><a class="reference internal" href="nonlinear.html">2.3. Nonlinear problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="variational_inequalities.html">2.4. Variational inequalities</a></li>
<li class="toctree-l2"><a class="reference internal" href="LSM.html">2.5. Level Set method I</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">2.6. Level Set method II</a></li>
<li class="toctree-l2"><a class="reference internal" href="3dext.html">2.7. Going 3d</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Structure_Mechanics/index_structmech.html">3. Structure mechanics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Fluid_Mechanics/index_fl.html">4. Fluid mechanics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Optimal_design/index_od.html">5. Optimal design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Appendix/index_app.html">6. Appendix</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Generalities/bibliography.html">7. Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Generalities/glossary.html">8. Glossary</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index_adv.html"><span class="section-number">2. </span>More advanced issues in scientific computing</a><ul>
      <li>Previous: <a href="LSM.html" title="previous chapter"><span class="section-number">2.5. </span>The Level Set method: Part I</a></li>
      <li>Next: <a href="3dext.html" title="next chapter"><span class="section-number">2.7. </span>Turning to 3d Finite Element problems</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;.
      
      |
      <a href="../_sources/Advanced/LSM2.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>