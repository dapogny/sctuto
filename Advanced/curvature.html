<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>2.2. Calculating curvature &#8212; Numerical tours in scientific computing</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=8203d6f3" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=25db1f2b" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="../_static/gen.css?v=1d84c916" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>window.MathJax = {"tex": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "macros": {"calA": "{{\\mathcal A}}", "calC": "{{\\mathcal C}}", "calI": "{{\\mathcal I}}", "calF": "{{\\mathcal F}}", "calL": "{{\\mathcal L}}", "bz": "{\\mathbf{0}}", "d": "{\\text{d}}", "dv": "{\\text{div}}", "e": "{\\varepsilon}", "be": "{\\textbf{e}}", "n": "{\\textbf{n}}", "t": "{\\textbf{t}}", "f": "{\\textbf{f}}", "g": "{\\textbf{g}}", "u": "{\\textbf{u}}", "m": "{\\textbf{m}}", "v": "{\\textbf{v}}", "p": "{\\textbf{p}}", "bj": "{\\textbf{j}}", "bC": "{\\textbf{C}}", "bF": "{\\textbf{F}}", "bU": "{\\textbf{U}}", "bV": "{\\textbf{V}}", "x": "{\\textbf{x}}", "y": "{\\textbf{y}}", "bX": "{\\textbf{X}}", "P": "{\\mathbb{P}}", "R": "{\\mathbb{R}}", "N": "{\\mathbb{N}}", "I": "{\\text{I}}", "Id": "{\\text{Id}}", "o": "{\\text{o}}", "calT": "{{\\mathcal T}}", "Hdiv": "{H_{\\text{div}}}", "tr": "{\\text{tr}}", "bold": ["{\\bf #1}", 1]}, "loader": {"load": ["[tex]/boldsymbol"]}, "packages": {"[+]": ["boldsymbol"]}}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="2.3. A first encounter with nonlinear problems" href="nonlinear.html" />
    <link rel="prev" title="2.1. Creating a mesh from an image" href="imgmesh.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="calculating-curvature">
<span id="sec-curvature"></span><h1><span class="section-number">2.2. </span>Calculating curvature<a class="headerlink" href="#calculating-curvature" title="Link to this heading">¶</a></h1>
<p>This section is devoted to the quite subtle notion of curvature of a curve, appraising how fast a point travelling on the latter changes direction,
and its practical calculation. We first recall a few basic facts about curvature in <a class="reference internal" href="#sec-defcurv"><span class="std std-numref">Section 2.2.1</span></a>, before describing its practical calculation with <span class="math notranslate nohighlight">\(\texttt{FreeFem}\)</span> in <a class="reference internal" href="#sec-calccurv"><span class="std std-numref">Section 2.2.2</span></a>. The notion of curvature being significantly more involved in higher space dimensions, we focus on the 2d case.</p>
<section id="definition-of-curvature">
<span id="sec-defcurv"></span><h2><span class="section-number">2.2.1. </span>Definition of curvature<a class="headerlink" href="#definition-of-curvature" title="Link to this heading">¶</a></h2>
<p>Throughout this section, we consider a 2d curve <span class="math notranslate nohighlight">\(\gamma\)</span>; with a small abuse of language, this terminology designates at the same time:</p>
<blockquote>
<div><ul class="simple">
<li><p>A mapping <span class="math notranslate nohighlight">\(\gamma: [a,b] \to \R^2\)</span> between a parameter <span class="math notranslate nohighlight">\(t\)</span> in some interval <span class="math notranslate nohighlight">\([a,b]\)</span> and a point <span class="math notranslate nohighlight">\(\gamma(t)\)</span> in the 2d plane;</p></li>
<li><p>The geometric locus of points formed by this mapping, i.e. the image <span class="math notranslate nohighlight">\(\gamma([0,T])\)</span>.</p></li>
</ul>
</div></blockquote>
<p>The curve <span class="math notranslate nohighlight">\(\gamma\)</span> may be open (i.e. <span class="math notranslate nohighlight">\(\gamma(a) \neq \gamma(b)\)</span>) or closed (i.e. <span class="math notranslate nohighlight">\(\gamma(a) = \gamma(b)\)</span>).</p>
<p>Note that multiple parametrizations describe the same geometric object: for instance, if <span class="math notranslate nohighlight">\(\alpha: [\widetilde{a},\widetilde{b}] \to [a,b]\)</span> is a smooth bijective mapping, <span class="math notranslate nohighlight">\(\widetilde{\gamma} = \gamma \circ \alpha: [\widetilde{a},\widetilde{b}] \to \R^2\)</span> is another parametrization for <span class="math notranslate nohighlight">\(\gamma\)</span>.</p>
<p>Let us first define first-order quantities related to <span class="math notranslate nohighlight">\(\gamma\)</span>.</p>
<div class="proof definition admonition" id="definition-0">
<p class="admonition-title"><span class="caption-number">Definition 2.1 </span></p>
<section class="definition-content" id="proof-content">
<p>Let <span class="math notranslate nohighlight">\(\gamma: [0,T] \to \R^2\)</span> be a curve of class <span class="math notranslate nohighlight">\(\calC^1\)</span>.</p>
<blockquote>
<div><ul>
<li><p>The velocity of <span class="math notranslate nohighlight">\(\gamma\)</span> is the derivative <span class="math notranslate nohighlight">\(\gamma^\prime : [0,T] \to \R^2\)</span>.</p></li>
<li><p>The curve <span class="math notranslate nohighlight">\(\gamma\)</span> is called simple when <span class="math notranslate nohighlight">\(\gamma^\prime\)</span> does not vanish on <span class="math notranslate nohighlight">\([0,T]\)</span>.</p></li>
<li><p>The unit tangent vector <span class="math notranslate nohighlight">\(\tau(\x)\)</span> to <span class="math notranslate nohighlight">\(\gamma\)</span> at a point <span class="math notranslate nohighlight">\(\x = \gamma(t)\)</span> where <span class="math notranslate nohighlight">\(\gamma^\prime(t) \neq 0\)</span> is:</p>
<p><div class="math notranslate nohighlight">
\[\forall \x = \gamma(t), \: t\in (0,T), \quad \tau(\x) = \frac{\gamma^\prime(t)}{\lvert\gamma^\prime(t) \lvert}.\]</div>
</p>
</li>
<li><p>The arc length of <span class="math notranslate nohighlight">\(\gamma\)</span> is the function <span class="math notranslate nohighlight">\(s: [0,T] \to \R\)</span> measuring the length from the initial value <span class="math notranslate nohighlight">\(t=0\)</span>:</p>
<p><div class="math notranslate nohighlight">
\[\forall t \in [0,T], \quad s(t) = \int_0^t \lvert \gamma^\prime(u)\lvert \:\d u.\]</div>
</p>
<p>One can prove that a simple curve <span class="math notranslate nohighlight">\(\gamma\)</span> may always be parametrized by its arc length, so that <span class="math notranslate nohighlight">\(\gamma\)</span> has constant, unit velocity:</p>
<p><div class="math notranslate nohighlight">
\[\forall \x = \gamma(t), \: t\in (0,T), \quad \lvert \gamma^\prime(t) \lvert =1. \]</div>
</p>
</li>
</ul>
</div></blockquote>
</section>
</div><p>The velocity <span class="math notranslate nohighlight">\(\gamma^\prime(t)\)</span> and the arc length <span class="math notranslate nohighlight">\(s(t)\)</span> of <span class="math notranslate nohighlight">\(\gamma\)</span> both depend on the chosen parametrization. On the contrary, the tangent vector <span class="math notranslate nohighlight">\(\tau(\x)\)</span>, giving the orientation of the tangent line to <span class="math notranslate nohighlight">\(\gamma\)</span> passing through a point <span class="math notranslate nohighlight">\(\x\)</span> on <span class="math notranslate nohighlight">\(\gamma\)</span>, only depends on the parametrization up to a sign, indicating the orientation of the curve, i.e. the sense of travel.
These notions are illustrated on <a class="reference internal" href="#fig-curvdef"><span class="std std-numref">Fig. 2.2</span></a>.</p>
<figure class="align-default" id="id1">
<span id="fig-curvdef"></span><a class="reference internal image-reference" href="../_images/curvdef.png"><img alt="../_images/curvdef.png" src="../_images/curvdef.png" style="width: 1228.16px; height: 344.28000000000003px;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 2.2 </span><span class="caption-text"><span class="math notranslate nohighlight">\((\)</span>a) Illustration of the first-order quantities attached to a curve <span class="math notranslate nohighlight">\(\gamma\)</span>; (b,c) Two different pathologies featured by non simple curves : (b) The curve <span class="math notranslate nohighlight">\(\gamma(t) = (t^2,t^3)\)</span>; (c) The curve <span class="math notranslate nohighlight">\(\gamma(t) = \left(\frac{\cos^2 t}{2+\sin(2t)},\frac{\sin^4 t}{2+\sin(2t)}\right)\)</span>.</span><a class="headerlink" href="#id1" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Let us now turn to the second-order features of a curve <span class="math notranslate nohighlight">\(\gamma: [a,b]\to \R^2\)</span> of class <span class="math notranslate nohighlight">\(\calC^2\)</span>. The acceleration vector of <span class="math notranslate nohighlight">\(\gamma\)</span> is the second-order derivative <span class="math notranslate nohighlight">\(\gamma^{\prime\prime} : [a,b] \to \R^2\)</span> of the parametrization.</p>
<div class="proof definition admonition" id="definition-1">
<p class="admonition-title"><span class="caption-number">Definition 2.2 </span></p>
<section class="definition-content" id="proof-content">
<p>Let <span class="math notranslate nohighlight">\(\gamma: [0,T] \to \R^2\)</span> be a simple curve of class <span class="math notranslate nohighlight">\(\calC^2\)</span>, parametrized by arc length. The curvature <span class="math notranslate nohighlight">\(\kappa(\x)\)</span> at the point <span class="math notranslate nohighlight">\(\x = \gamma(t)\)</span> is defined by</p>
<p><div class="math notranslate nohighlight">
\[k(\x) = \lvert \gamma^{\prime\prime}(t) \lvert. \]</div>
</p>
</section>
</div><p>To get an insight about curvature, let us assume that <span class="math notranslate nohighlight">\(\gamma\)</span> is parametrized by arc length and let <span class="math notranslate nohighlight">\(\x_0 = \gamma(t_0)\)</span> be a point on <span class="math notranslate nohighlight">\(\gamma\)</span>. A Taylor expansion of <span class="math notranslate nohighlight">\(\gamma\)</span> around <span class="math notranslate nohighlight">\(t_0\)</span> yields:
<div class="math notranslate nohighlight">
\[\gamma(t) \approx \gamma(t_0) + (t-t_0)\gamma^\prime(t_0) + \frac12 (t-t_0)^2 \gamma^{\prime\prime}(t_0). \]</div>

Here,</p>
<blockquote>
<div><ul class="simple">
<li><p>The vector <span class="math notranslate nohighlight">\(\gamma^\prime(t_0) = \tau(\x_0)\)</span> is the unit tangent vector to <span class="math notranslate nohighlight">\(\gamma\)</span> at <span class="math notranslate nohighlight">\(\x_0\)</span>;</p></li>
<li><p>The acceleration <span class="math notranslate nohighlight">\(\gamma^{\prime\prime}(t_0)\)</span> is orthogonal to <span class="math notranslate nohighlight">\(\tau(\x_0)\)</span>, since
<div class="math notranslate nohighlight">
\[\lvert \gamma^\prime(t)\lvert^2 = 1 \quad\Rightarrow \quad \gamma^\prime(t) \cdot \gamma^{\prime\prime}(t) = 0.\]</div>

We denote by <span class="math notranslate nohighlight">\(\n_\gamma(\x) = \frac{\gamma^{\prime\prime}(t_0)}{\lvert \gamma^{\prime\prime}(t_0) \lvert}\)</span> the unit normal vector to <span class="math notranslate nohighlight">\(\gamma\)</span> at <span class="math notranslate nohighlight">\(\x_0\)</span>.</p></li>
</ul>
</div></blockquote>
<p>With these notations, the above expansion rewrites:
<div class="math notranslate nohighlight">
\[\gamma(t) \approx \x_0 + (t-t_0)\tau(\x_0) + \frac12 (t-t_0)^2 k(x_0) \n_\gamma(\x_0). \]</div>

This expansion reflects the local behavior of <span class="math notranslate nohighlight">\(\gamma\)</span> near <span class="math notranslate nohighlight">\(\x_0 = \gamma(t_0)\)</span>: at first order, <span class="math notranslate nohighlight">\(\gamma\)</span> follows the tangent direction <span class="math notranslate nohighlight">\(\tau(\x_0)\)</span>. Its normal deviation is encoded in the second-order term: the larger the curvature <span class="math notranslate nohighlight">\(k(\x_0)\)</span>, the faster it is; see <a class="reference internal" href="#fig-curvdef2"><span class="std std-numref">Fig. 2.3</span></a> for an illustration.</p>
<figure class="align-default" id="id2">
<span id="fig-curvdef2"></span><a class="reference internal image-reference" href="../_images/curvdef2.png"><img alt="../_images/curvdef2.png" src="../_images/curvdef2.png" style="width: 967.1999999999999px; height: 442.8px;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 2.3 </span><span class="caption-text">Illustration of the second-order quantities attached to a curve <span class="math notranslate nohighlight">\(\gamma\)</span>; (a) A situation where the curvature <span class="math notranslate nohighlight">\(k(\x_0)\)</span> is relatively small; (b) A situation where <span class="math notranslate nohighlight">\(k(\x_0)\)</span> is large.</span><a class="headerlink" href="#id2" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The curvature <span class="math notranslate nohighlight">\(k(\x)\)</span> is an unsigned quantity. It is customary to endow it with a sign in the particular situation where <span class="math notranslate nohighlight">\(\gamma\)</span> is closed, and thus delimits an interior domain <span class="math notranslate nohighlight">\(\Omega \subset \R^2\)</span>. In this situation, let <span class="math notranslate nohighlight">\(\n\)</span> be the unit normal vector to <span class="math notranslate nohighlight">\(\gamma\)</span> pointing outward <span class="math notranslate nohighlight">\(\Omega\)</span>, whose orientation may differ from that of the normal vector <span class="math notranslate nohighlight">\(\n_\gamma\)</span> defined above. We define the oriented curvature <span class="math notranslate nohighlight">\(\kappa(\x)\)</span> of <span class="math notranslate nohighlight">\(\gamma\)</span> at <span class="math notranslate nohighlight">\(\x\)</span> by:
<div class="math notranslate nohighlight">
\[\kappa(\x) = -\gamma^{\prime\prime}(s) \cdot \n(\x);\]</div>

in other terms, <span class="math notranslate nohighlight">\(\kappa(\x) = \pm k(\x)\)</span>, where the sign is that of the product <span class="math notranslate nohighlight">\(-\n(\x) \cdot \n_\gamma(\x)\)</span>.
Note that the oriented curvature is positive when <span class="math notranslate nohighlight">\(\gamma\)</span> is locally convex near <span class="math notranslate nohighlight">\(\x\)</span>, positive otherwise, see <a class="reference internal" href="#fig-curv2d"><span class="std std-numref">Fig. 2.4</span></a>.</p>
<figure class="align-default" id="id3">
<span id="fig-curv2d"></span><a class="reference internal image-reference" href="../_images/curv2d.png"><img alt="../_images/curv2d.png" src="../_images/curv2d.png" style="width: 777.5px; height: 250.5px;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 2.4 </span><span class="caption-text">(Left) The domain <span class="math notranslate nohighlight">\(\Omega\)</span> is convex near <span class="math notranslate nohighlight">\(\x\)</span>: <span class="math notranslate nohighlight">\(\kappa(\x) &gt; 0\)</span>; (right) <span class="math notranslate nohighlight">\(\Omega\)</span> is concave near <span class="math notranslate nohighlight">\(\x\)</span>: <span class="math notranslate nohighlight">\(\kappa(\x) &lt; 0\)</span>.</span><a class="headerlink" href="#id3" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<div class="proof example admonition" id="example-2">
<span id="ex-curvball"></span><p class="admonition-title"><span class="caption-number">Example 2.1 </span></p>
<section class="example-content" id="proof-content">
<p>Let <span class="math notranslate nohighlight">\(\Omega = B(\bz,R)\)</span> be the disk centred at the origin <span class="math notranslate nohighlight">\(\bz\)</span>, with radius <span class="math notranslate nohighlight">\(R\)</span>. The curvature <span class="math notranslate nohighlight">\(\kappa(\x)\)</span> at any point <span class="math notranslate nohighlight">\(\x \in \partial \Omega\)</span> equals <span class="math notranslate nohighlight">\(\frac{1}{R}\)</span>, i.e. the larger the disk, the more &quot;flat&quot; its boundary appears.</p>
</section>
</div></section>
<section id="calculation-of-the-mean-curvature-from-a-mesh">
<span id="sec-calccurv"></span><h2><span class="section-number">2.2.2. </span>Calculation of the mean curvature from a mesh<a class="headerlink" href="#calculation-of-the-mean-curvature-from-a-mesh" title="Link to this heading">¶</a></h2>
<p>Let <span class="math notranslate nohighlight">\(\Omega\)</span> be a smooth bounded domain, equipped with a mesh <span class="math notranslate nohighlight">\(\calT_h\)</span>. We aim to calculate the mean curvature <span class="math notranslate nohighlight">\(\kappa\)</span> at the points <span class="math notranslate nohighlight">\(\x\)</span> of the boundary <span class="math notranslate nohighlight">\(\partial \Omega\)</span>.</p>
<p>The first step to achieve this goal is to approximate the unit normal vector <span class="math notranslate nohighlight">\(\n\)</span> to <span class="math notranslate nohighlight">\(\partial\Omega\)</span>.
Let <span class="math notranslate nohighlight">\(\x_{i-1}\)</span>, <span class="math notranslate nohighlight">\(\x_i\)</span> and <span class="math notranslate nohighlight">\(\x_{i+1}\)</span> be three successive vertices on the discrete boundary <span class="math notranslate nohighlight">\(\partial \Omega\)</span>, enumerated in counterclockwise order.
The tangent vector <span class="math notranslate nohighlight">\(\t(\x_i)\)</span> to <span class="math notranslate nohighlight">\(\partial \Omega\)</span> at <span class="math notranslate nohighlight">\(\x_i\)</span> is approximated as:</p>
<p><div class="math notranslate nohighlight">
\[\tau(\x_i) \approx \frac{\x_{i-1}-\x_{i+1} }{\lvert \x_{i-1}-\x_{i+1} \lvert}.\]</div>
</p>
<p>The normal vector <span class="math notranslate nohighlight">\(\n(\x_i)\)</span> is then obtained as the clockwise <span class="math notranslate nohighlight">\(90\)</span> rotate of <span class="math notranslate nohighlight">\(\tau(\x_i)\)</span>; see <a class="reference internal" href="#fig-curvapprox"><span class="std std-numref">Fig. 2.5</span></a>.</p>
<p>In <span class="math notranslate nohighlight">\(\texttt{FreeFem}\)</span>, the normal vector <span class="math notranslate nohighlight">\(\n\)</span> can be calculated in a simpler way, which uses the reserved keywords <code class="code docutils literal notranslate"><span class="pre">N.x</span></code> and <code class="code docutils literal notranslate"><span class="pre">N.y</span></code>.
These can only be used inside a one-dimensional integral <code class="code docutils literal notranslate"><span class="pre">int1d(Th)</span></code> call, and they represent the components of the normal vector field to the considered boundary. The following trick allows to calculate (an extension to <span class="math notranslate nohighlight">\(\Omega\)</span> of) them as <span class="math notranslate nohighlight">\(\P_1\)</span> Finite Element functions on <span class="math notranslate nohighlight">\(\calT_h\)</span>:</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Calculation of the normal vector to a meshed interface */</span>
<span class="cm">/* Finite element spaces and functions */</span>
<span class="kt">fespace</span><span class="w"> </span><span class="nf">Ph</span><span class="p">(</span><span class="n">Th</span><span class="p">,</span><span class="nc">P1</span><span class="p">);</span>
<span class="n">Ph</span><span class="w"> </span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">,</span><span class="n">norm</span><span class="p">;</span>

<span class="cm">/* Calculation of the normal vector to all borders of the mesh */</span>
<span class="kt">real</span><span class="w"> </span><span class="n">EPS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.</span><span class="n">e</span><span class="mi">-5</span><span class="p">;</span>
<span class="kt">varf</span><span class="w"> </span><span class="nf">normalx</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">int1d</span><span class="p">(</span><span class="n">Th</span><span class="p">)(</span><span class="kr">N</span><span class="p">.</span><span class="kr">x</span><span class="o">*</span><span class="n">v</span><span class="p">);</span>
<span class="kt">varf</span><span class="w"> </span><span class="nf">normaly</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">int1d</span><span class="p">(</span><span class="n">Th</span><span class="p">)(</span><span class="kr">N</span><span class="p">.</span><span class="kr">y</span><span class="o">*</span><span class="n">v</span><span class="p">);</span>

<span class="n">nx</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normalx</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Ph</span><span class="p">);</span>
<span class="n">ny</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normaly</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Ph</span><span class="p">);</span>
<span class="n">norm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">sqrt</span><span class="p">(</span><span class="n">nx</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="n">ny</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="n">EPS</span><span class="o">^</span><span class="mi">2</span><span class="p">);</span>
<span class="n">nx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nx</span><span class="o">/</span><span class="n">norm</span><span class="p">;</span>
<span class="n">ny</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ny</span><span class="o">/</span><span class="n">norm</span><span class="p">;</span>
</pre></div>
</div>
<p>Once <span class="math notranslate nohighlight">\(\n(\x_i)\)</span> is available, the following approximation formula allows to calculate the mean curvature <span class="math notranslate nohighlight">\(\kappa(\x_i)\)</span>:</p>
<p><div class="math notranslate nohighlight">
\[\frac{1}{\kappa(\x_i)} \approx - \frac{1}{4} \left( \frac{ (\x_{i-1}- \x_{i}) \cdot (\x_{i-1}- \x_{i}) }{\n(\x_i) \cdot  (\x_{i-1}- \x_{i}) } + \frac{ (\x_{i+1}- \x_{i}) \cdot (\x_{i+1}- \x_{i})}{\n(\x_i) \cdot  (\x_{i+1}- \x_{i}) }  \right).\]</div>
</p>
<figure class="align-default" id="id4">
<span id="fig-curvapprox"></span><a class="reference internal image-reference" href="../_images/curvatureexplanation.png"><img alt="../_images/curvatureexplanation.png" src="../_images/curvatureexplanation.png" style="width: 534.75px; height: 339.5px;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 2.5 </span><span class="caption-text">Approximation of the curvature of a domain <span class="math notranslate nohighlight">\(\Omega\)</span> from a meshed discretization.</span><a class="headerlink" href="#id4" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>This idea is implemented in the function <span class="math notranslate nohighlight">\(\texttt{curvatureFromMesh}\)</span>, contained in the independent module <a class="reference download internal" download="" href="../_downloads/5e99f47c247afb320d01773964c17bf1/curvature.idp"><code class="xref download docutils literal notranslate"><span class="pre">curvature.idp</span></code></a>, which is called as follows:</p>
<div class="highlight-freefem notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Calculation of the mean curvature kappa from the datum of the normal vector (nx,ny) */</span>
<span class="n">curvatureFromMesh</span><span class="p">(</span><span class="n">Th</span><span class="p">,</span><span class="n">nx</span><span class="p">[],</span><span class="n">ny</span><span class="p">[],</span><span class="n">kappa</span><span class="p">[]);</span>
</pre></div>
</div>
<div class="admonition-exo admonition">
<p class="admonition-title">Exercise</p>
<p>Use these <span class="math notranslate nohighlight">\(\texttt{FreeFem}\)</span> recipes to:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Calculate the mean curvature of the unit ball; compare the result with the theoretical value <span class="math notranslate nohighlight">\(\kappa=1\)</span>, see <a class="reference internal" href="#ex-curvball"><span class="std std-numref">example 2.1</span></a>.</p></li>
<li><p>Calculate the mean curvature of an ellipse with semi-axes <span class="math notranslate nohighlight">\(0.1\)</span> and <span class="math notranslate nohighlight">\(0.2\)</span>.</p></li>
</ol>
</div></blockquote>
</div>
<p>A numerical result is presented in <a class="reference internal" href="#fig-calccurv"><span class="std std-numref">Fig. 2.6</span></a>, and the associated code can be downloaded <a class="reference download internal" download="" href="../_downloads/559c8d356afc0d1992612190503f9ed7/test_curvature.edp"><code class="xref download docutils literal notranslate"><span class="pre">here</span></code></a>.</p>
<figure class="align-default" id="id5">
<span id="fig-calccurv"></span><a class="reference internal image-reference" href="../_images/calccurv.png"><img alt="../_images/calccurv.png" src="../_images/calccurv.png" style="width: 770.6999999999999px; height: 381.5px;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 2.6 </span><span class="caption-text"><span class="math notranslate nohighlight">\((\)</span>a) Mesh of a box, containing a subdomain shaped as an ellipse; (b) Approximation of the curvature of all the boundaries of the mesh (including those of the bounding box).</span><a class="headerlink" href="#id5" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<div class="proof remark admonition" id="remark-3">
<p class="admonition-title"><span class="caption-number">Remark 2.1 </span></p>
<section class="remark-content" id="proof-content">
<p>The curvature of the boundary <span class="math notranslate nohighlight">\(\partial\Omega\)</span> of a domain <span class="math notranslate nohighlight">\(\Omega\)</span> can be calculated in a different fashion when the latter is represented by a level set function, as we shall see in the next <a class="reference internal" href="LSM.html#sec-curvaturels"><span class="std std-numref">Section 2.5.2.2</span></a>.</p>
</section>
</div></section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index.html">
    <img class="logo" src="../_static/falcmill.png" alt="Logo" />
    
  </a>
</p>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../Generalities/index_gen.html">1. Generalities</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index_adv.html">2. Advanced features</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="imgmesh.html">2.1. Meshing images</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">2.2. Curvature</a></li>
<li class="toctree-l2"><a class="reference internal" href="nonlinear.html">2.3. Nonlinear problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="variational_inequalities.html">2.4. Variational inequalities</a></li>
<li class="toctree-l2"><a class="reference internal" href="LSM.html">2.5. Level Set method I</a></li>
<li class="toctree-l2"><a class="reference internal" href="LSM2.html">2.6. Level Set method II</a></li>
<li class="toctree-l2"><a class="reference internal" href="3dext.html">2.7. Going 3d</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Structure_Mechanics/index_structmech.html">3. Structure mechanics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Fluid_Mechanics/index_fl.html">4. Fluid mechanics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Optimal_design/index_od.html">5. Optimal design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Appendix/index_app.html">6. Appendix</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Generalities/bibliography.html">7. Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Generalities/glossary.html">8. Glossary</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index_adv.html"><span class="section-number">2. </span>More advanced issues in scientific computing</a><ul>
      <li>Previous: <a href="imgmesh.html" title="previous chapter"><span class="section-number">2.1. </span>Creating a mesh from an image</a></li>
      <li>Next: <a href="nonlinear.html" title="next chapter"><span class="section-number">2.3. </span>A first encounter with nonlinear problems</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;.
      
      |
      <a href="../_sources/Advanced/curvature.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>